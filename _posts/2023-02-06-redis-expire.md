---
title: Redis过期key删除和缓存淘汰策略
date: 2023-02-22 01:12:00 +0800
pin: false 
categories: [3.数据库/中间件,Redis]
tags: [Redis]
---

## 过期key删除策略

在我们用 redis 存储数据时，大多数场景都会给key设置一个过期时间，那么当key过期后，redis是如何处理的呢。大家可能会想到定时器的方案，当我们给key设置过期时间的同时设置一个定时器，到达时间后，删除过期的key，但这种方式在内存不紧张但Cpu紧张时，将cpu时间用在删除过期key上，无疑会对系统的吞吐量造成影响。所以redis没有采用这种方案，而是使用了 惰性删除+定期删除的方式。

- 惰性删除：当客户端查询数据时，redis会先查询expires字典(redis内部会额外维护一个记录<key,过期时间>的字典) ,如果key设置了过期时间并且已经过期，redis会直接将记录删掉，返回空记录给客户端。这种读时删除，我们称它为`惰性删除`。

- 定期删除：惰性删除对cpu来讲是友好的，但是对内存来讲并不友好，如果大量的过期key一直不被访问，就会一直占用着内存空间，所以需要定期的删除，减轻过期key对内存的影响。redis默认会以每秒10次的频率，在expires字典中随机检查key的过期时间，然后在数据字典中删除已经过期的key-value。

### AOF、RDB和复制功能对过期key的处理

在执行save或bgsave命令创建一个新的RDB文件时，redis会对键进行检查，已过期的键不会保存到RDB文件中。

当启用了rdb持久化策略，在启用redis时，服务器会对rdb文件进行载入。如果是主库，载入rdb文件时，会对键进行检查，已过期的键不会载入到redis中。如果是从库载入rdb文件时，不论key是否过期，都会被载入到redis中，但这不会对redis造成影响。因为主从服务器进行数据同步时，从数据库的数据会被清空。

当redis使用aof持久化策略，当redis删除一条过期key时，会同时向aof文件中追加一条del命令。在执行aof重写的过程中，程序会对数据库中的键进行检查，已过期的建不会被保存到重写的aof文件中。

当服务器运行在复制模式下时，从服务器的过期键删除动作有主服务器控制，所以读写分离模式下，会出现key过期但仍有效的问题。（reidis3.2已修复）

## 缓存淘汰策略

maxmemory 用于指定 redis的最大可用内存。我们可以通过下面的配置将 redis的可用内存设置为 100mb。

```
maxmemory 100mb
```

如果系统对redis的使用量很大，内存被写满时，再有客户端的写入请求进来，redis会怎样处理呢，这个时候就要提到 redis的 缓存淘汰策略了。

- noeviction :  当内存超过配置内存时，会返回错误，不会删除任何键。
- allkeys-lru:  当内存不足以处理新加入的键时，按照lru算法驱逐最久没有使用的键。（建议使用）
- volitile-lru: 当内存不足以处理新加入的键时，按照lru算法在设置了过期时间的key中，驱逐最久没有使用的键。
- allkeys-random: 当内存不足以处理新加入的键时，随机驱逐键。（不建议使用）
- volitile-random: 当内存不足以处理新加入的键时，在设置了过期时间的key中，随机驱逐键。
- volitile-ttl: 当内存不足以处理新加入的键时，驱逐马上要过期的键。
- allkeys-lfu: 当内存不足以处理新加入的键时，按照lfu算法驱逐使用频率最低的键。
- volitile-lfu: 当内存不足以处理新加入的键时，按照lfu算法在设置了过期时间的key中，驱逐使用频率最低的键。

redis的默认缓存淘汰策略是 noeviction，我们可以按照上面的说明选择最合适的方案。

```
maxmemory-policy noeviction
```