---
title: 数据结构与算法：复杂度分析
date: 2023-11-10 10:12:00 +0800
categories: [数据结构与算法]
toc: true
tags: [数据结构与算法]
---

## 为什么需要复杂度分析

数据结构与算法要解决的是快和省的问题，即如何让代码运行的更快，如何让代码更省存储空间。那么，执行效率就是算法一个非常重要的考量指标。事后统计法虽然也能帮助我们了解算法的执行效率，但是它有很大的局限性。一是非常依赖测试环境，不同级别的硬件设备，会显示出截然不同的结果；二是测试结果受到数据规模的影响，数据规模较小时，无法表现出一些算法的特性。而时间、空间复杂度分析就可以帮助我们科学的衡量算法的执行效率。

## 大O复杂度表示法

### 时间复杂度

算法的执行效率，粗略的讲，就是算法的执行时间。假设cpu执行每一行代码的时间都是相同的，设为1，那么下面这段代码总的执行时间就是(2n+2),可以看出所有代码的执行时间T(n)与每行代码的执行次数f(n)成正比。将这个规律总结为一个公式即T(n)=O(f(n)),n表示数据规模的大小。

```
 int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```

大O时间复杂度表示法，并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫做渐进时间复杂度，简称时间复杂度。当n很大时，10000，100000更多时，公式中的低阶，常量，系数三部分并不能左右增长趋势，所以可以忽略，只需要记录一个最大量级既可以了。用大O表示法表示刚才的代码的时间复杂度，就是 T(n)=O(n)。

分析时间复杂度的三个实用方法：

1. 只关注循环执行次数最多的一段代码
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

常见的时间复杂度

![](/assets/img/complexity/001.png)

![](/assets/img/complexity/002.png)

### 空间复杂度

时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。

#### 最好、最坏情况时间复杂度

```
// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

上面这段代码的功能是，在一个无序数组array中，查找变量x的位置。因为，要查找的变量 x 可能出现在数组的任意位置。如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)。但如果数组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。所以，不同的情况下，这段代码的时间复杂度是不一样的。

最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。就像我们刚刚讲到的，在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度。

同理，最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。就像刚举的那个例子，如果数组中没有要查找的变量 x，我们需要把整个数组都遍历一遍才行，所以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂度。

#### 平均情况时间复杂度

最好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的代码复杂度，发生的概率其实并不大。为了更好地表示平均情况下的复杂度，我们需要引入另一个概念：平均情况时间复杂度。

要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值，但我们知道，要查找的变量 x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便你理解，我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。

那么平均时间复杂都的计算过程就是这样：

![](/assets/img/complexity/003.png)

这个值就是概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。前面那段代码的加权平均值为 (3n+1)/4。用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 O(n)。

实际上，在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。很多时候，我们使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。