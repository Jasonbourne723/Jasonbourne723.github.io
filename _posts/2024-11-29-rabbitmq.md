---
title: RabbitMQ
date: 2024-11-29 10:12:00 +0800
categories: [8.技术之外]
tags: []
hidden: false
---

> RabbitMQ是目前非常热门的一款消息中间件，其凭借高可靠、易扩展、高可用及丰富的功能特性受到众多开发者的青睐，在互联网、金融传统行业中都在大量的使用。

## 消息中间件

### 什么是消息中间件

消息中间件，也称消息队列，是一种进程间通信方式。它允许应用程序发送消息到队列中，无需立即处理，而是可以存储起来，直到有进程或线程准备好去处理它们。消息队列作为一种中间件，不仅存储消息，还负责消息的传输，使得发送者和接收者之间实现了解耦。

它一般有两种传递模式：点对点模式和发布/订阅模式。点对点模式基于队列，消息生产者将消息发送至队列，消费者从队列中接受消息，队列的存在实现了消息的异步传输。发布/订阅模式基于主题，主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，消息订阅者从主题中订阅消息。发布/订阅模式在消息的一对多广播时采用。

### 消息中间件的作用

- 解耦：上游服务只需要将事件发布到消息中间件，降低了对下游服务的依赖。通过在系统中增加中间层（消息中间件），实现了业务间的解耦。
- 削峰填谷：消息中间件可以对瞬发的流量洪峰进行缓冲，让后端服务从容的应对流量压力。
- 异步通信：通过将事件发布到消息中间件实现异步处理，进而提升服务的吞吐量。

### 开源消息中间件对比

|名称| 吞吐量           |集群支持|多客户端支持| 扩展性      |特点|典型应用场景|
|--|---------------|--|--|----------|--|--|
|ActiveMQ| 低（几千到万级消息/秒） |支持|支持大部分主流语言| 差        |无|传统应用系统、企业内部集成|
|RabbitMQ| 中等（万级消息/秒）    |支持|支持大部分主流语言| 一般       |支持AMQP,多租户，界面友好|短信、推送、异步任务处理|
|RocketMQ| 高（十万级消息/秒）    |支持|java语言| 强，支持水平扩展 |分布式事务|金融、电商、分布式事务、数据传输|
|Kafka| 极高（百万级消息/秒）   |支持|支持大部分主流语言| 强，支持水平扩展  |回溯消费,主题分区多副本,数据持久化保存|大数据处理、日志收集、实时分析|

## RabbitMQ 介绍

RabbitMQ 是基于 Erlang 语言实现 AMQP(高级消息队列协议) 的消息中间件，它最初起源于金融系统，用于分布式系统中存储转发消息。它的主要特点如下：

- 可靠性：通过持久化、发布确认、传输确认等机制保证消息可靠性。
- 灵活的路由：通过不同模式的交换器，可以实现多种消息路由方式。
- 扩展性：可以通过部署多个 RabbitMQ 节点组建集群，并可以动态扩展集群节点。
- 高可用性：队列可以在集群的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。
- 多种协议：RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP、MQTT 等多种消息中间件协议。
- 多语言客户端：RabbitMQ 几乎支持所有常用语言，比如 Java、C#、Go、Python等。
- 管理界面：RabbitMQ 提供了一个易用的用户界面，方便用户对消息进行管理和监控。
- 插件机制：RabbitMQ 提供了许多插件，以实现多方面扩展。

## 使用 Docker 部署 RabbitMQ

> Rabbit镜像仓库：https://hub.docker.com/_/rabbitmq

在装有 Docker 的环境下，执行以下命令安装 RabbitMQ：

```shell
docker run -d --name rabbit1 -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 5672:5672 -p 15672:15672  rabbitmq:3-management
```
- name：指定容器名称
- RABBITMQ_DEFAULT_USER：默认用户
- RABBITMQ_DEFAULT_PASS：默认密码
- -p 5672:5672：服务默认侦听端口 5672
- -p 15672:15672：web 管理页面端口 15672

执行成功后，访问 `http://localhost:15672`，即可进入 RabbitMQ 管理界面。

## RabbitMQ 基础概念

### 生产者与消费者

#### 生产者(Producer)

生产者创建消息，然后发布到 RabbitMQ 中。消息一般可以包含 2 个部分:消息体和标签。消息体也可以称之为 payload，在实际应用中，消息体一般是一个带有业务逻辑结构的数据，比如一个 JSON 字符串。当然可以进一步对这个消息体进行序列化操作。消息的标签用来表述这条消息 ， 比如一个交换器的名称和一个路由键。 生产者把消息交由 RabbitMQ， RabbitMQ 之后会根据标签把消息发送给相关的消费者。

#### 消费者(Consumer)

消费者连接到 RabbitMQ 服务器，并订阅到队列上。 当消费者消费一条消息时， 只是消费 消息的消息体 Cpayload)。 在消息路由的过程中 ， 消息的标签会丢弃， 存入到队列中的消息只 有消息体，消费者也只会消费到消息体， 也就不知道消息的生产者是谁，当然消费者也不需要 知道。

#### Broker

对于 RabbitMQ 来说， 一个 RabbitMQ Broker 可 以简单地看作一个 RabbitMQ 服务节点 ， 或者 RabbitMQ 服务实例 。 大多数情况下也可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器。

### 队列与交换器

#### 队列(queue)

队列是 RabbitMQ 的内部对象，用于存储消息。RabbitMQ 的消息只能存储在队列中。消费者可以从队列中获取消息并消费。如多个消费者订阅同一个队列，这时队列内的消息会被平均分摊（轮询）给多个消费者处理。

#### 交换器(Exchange)

RabbitMQ 中，生产者会将消息先发送到交换器，然后由交换器根据路由规则将消息转发到队列中，如果路由不到，或许会返回给生产者，或许直接丢弃。

交换器有四种类型：
- fanout：会将所有发送到该交换器的消息路由到与该交换器绑定的所有队列中。
- direct：会将消息路由到那些 BindingKey 和 RoutingKey 完全匹配的队列中。
- topic：与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队 列中，但这里的匹配规则有些不同，它约定:
  - RoutingKey 为一个点号". "分隔的字符串(被点号" "分隔开的每一段独立的字符 串称为一个单词 )，如“com.rabbitmq.client”;　　
  - BindingKey 和 RoutingKey 一样也是点号". "分隔的字符串;
  - BindingKey 中可以存在两种特殊字符串"*"和"#"，用于做模糊匹配，其中"*"用于匹配一个单词，"#"用于匹配多规格单词(可以是零个)。
- header：header 类型的交换器不依赖于路由键的匹配规则路由消息，而是根据消息内容中的 header 属性进行匹配。该类型的交换器性能很差，而且也不实用，基本上不会看到它的存在。

#### 绑定(Binding)

RabbitMQ 中通过绑定将交换器与队列关联起来，在绑定的时候一般会指定一个绑定键 (BindingKey)，这样 RabbitMQ 就知道如何正确地将消息路由到队列了。

#### 路由键(routingkey)

生产者将消息发送给交换器时，一般会指定一个routingkey，用来指定消息的路由规则， routingkey需要与交换器类型和绑定键 (BindingKey) 联合使用才能最终生效。

