---
title: 数据库：页缓存
date: 2025-07-27 10:12:00 +0800
categories: [数据库]
tags: []
hidden: false
---

大多数数据库都会使用两种存储介质，读写速度较慢的磁盘以及读写速度较快快的内存。为了减少访问磁盘次数，通常会将数据页缓存在内存中，也就是页缓存或缓冲池。

### 缓存在读写中的应用

处理读请求时，如果数据所在页刚好在内存中，则直接从内存返回数据，如果数据页不在内存中，则需要将数据页从磁盘中加载到内存，然后再返回给客户端，后续该数据页上的数据请求，就可以直接通过内存处理了。

很多数据库使用B+树数据结构，数据新增、修改都可能会导致页分裂、页合并，而频繁的执行这种操作，会导致数据库性能低下。其实写操作也可以应用缓存机制，当数据发生修改时，数据库会先在缓存中修改数据，之后在合适的时机将内存页刷回磁盘，这样可以将多次写磁盘操作合并成一次写入，降低了与磁盘交互的次数，从而提升数据库的整体性能。

### 故障恢复

在缓存中的数据页被修改后，它就变成了脏页（通常用一个字段标识），此时它与磁盘中的数据页会处在不一致的状态，如果此时服务器发生故障（断电、重启），缓存数据则会丢失，作为一个具有事务特性的数据库，是不能容忍已提交的数据丢失的，那么数据库会通过怎样的方式防止服务器故障对持久性的影响呢？

预写日志(wal,write ahead log)，它使数据库具有了崩溃恢复的能力，大多数数据库都通过 wal 机制保证持久性。

当数据库收到写请求时，首先在 wal 中顺序追加一条操作日志，然后再修改内存数据页，注意预写日志是写在磁盘文件中的，它属于持久化存储，所以当故障导致内存脏页丢失时，数据库就可以通过 wal 去恢复内存中的数据。有人可能会问，这样不就意味着每次写操作都有一次磁盘写操作，不会有性能问题吗？其实不会的，因为 wal 属于顺序写，磁盘顺序写的性能优于随机写的性能很多倍，同时文件系统也是有缓存机制的，如果你对数据库写性能的要求很高，可以不在每次记录日志后都执行 flush 操作，这样只要服务器不死机，也不会有数据丢失的问题。当然如何你对数据库的持久性要求更高的话，那么我还是建议你开启 每次日志后执行 flush 操作。

wal 通过维护 checkpoint (通常记录在 wal 头)来记录刷脏页的进度，写操作越多，wal 积攒的越快，当 wal 大小超过预设大小限制时，系统会开启强制刷脏页(触发刷脏页的时机参考[刷脏页](https://jasonbourne723.github.io/posts/mysql-flush/))，随着刷脏页的进行，checkpoint 会逐渐向后移动。故障恢复时，数据库会从 checkpoint 开始恢复。

### 缓存置换策略

保持内存高使用率是件好事，说明此时大部分数据都在内存中，可以减少磁盘的参与，但内存大小是有限制的，当数据量非常大时，不可能将全部数据都加载到内存中，当需要从磁盘中加载数据到内存并且内存空间不足时，需要先将一些旧页淘汰或者将脏页刷回磁盘，然后再将新页加载到内存中。这种操作称为缓存置换。

置换哪些页面其实也是有讲究的，比如，淘汰掉了一个读写频率高的页，下次操作又需要将其重新加载到内存中，那么这个操作其实是低效的。数据库应该尽量保证读写频率高的页常驻在内存中，淘汰掉那些很少会被访问到的页。一个优秀的缓存置换算法，可以最大化的利用有限的内存空间。

介绍几种基础的缓存置换策略：

1. fifo(先进先出)：内存中维护一个队列，新页加到队尾，内存不足时，从队头淘汰。该策略不受页读写频率的影响，简单粗暴，不具备现实意义，应该没有数据库会使用该策略。
2. lru(最近最少使用)：内存中维护一个队列，新页加到队尾，每次对页进行读写时，也会将其移动到队尾，相比于 fifo 做出一定的优化，但是如果用户突然访问大量新数据页，可能导致读写频率高的页淘汰掉。
3. lfu(最少频率使用)：在一段时间内,数据被使用频次最少的,优先被淘汰。最简单方法是为每个加载到缓存的块分配一个计数器。每次引用该块时，计数器将增加一。当缓存达到容量并有一个新的内存块等待插入时，系统将搜索计数器最低的块并将其从缓存中删除。
